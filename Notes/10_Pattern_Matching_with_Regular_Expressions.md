# 正则表达式的模式匹配
正则表达式(regular expression)是一个描述字符模式的对象。Javascript的RegExp类表示正则表达式，String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。Javascript的正则表达式语法是Perl5的正则表达式语法的大型子集。

## 10.1 正则表达式的定义
Javascript中的正则表达式用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象，不过RegExp对象更多的是通过一种铁直接量语法来创建。就像通过绰号包裹字符的方式来定义字符串直接量一样，正则表达式直接量定义为包含在对斜杠(/)之间的字符，如：

```javascript
var pattern = /s$/;
```

运行这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。这个特殊的RegExp对象用来匹配所有以字母`s`结尾的字符串，用构造函数RegExp()也可以定义一个与之等价的正则表达式，如：

```javascript
var pattern = new RegExp("s$");
```

### 10.1.1 直接量字符
正则表达式中的所有字母和数字都是按照字面含义进行匹配的。Javascript正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线(\)作为前缀进行转义，如\n用以匹配换行符，其他转义字符如：

字符 | 匹配
--- | ---
字母和数字字符 | 自身
\o | NUL字符(\u0000)
\t | 制表符(\u0009)
\n | 换行符(\u000A)
\v | 垂直制表符(\u000B)
\f | 换页符(\u000f)
\r | 回车符(\u000D)
\xnn | 由十六进制数nn指定的拉丁字符
\u0000 | 由十六进制数xxxx指定的Unicode字符
\cX | 控制字符^X

在正则表达中，许多标点符号具有特殊含义，它们是：

```javascript
^ $ . * + ? = ! : | \ / ( ) [ ] { }
```

某些符号只有在正则表达式的某些上下文中才具有某种特殊含义，在其他上下文中则被当成直接量处理。然而，如果想在正则表达式中使用这些字符的直接量进行匹配，则必须使用前经\，这是一条通用规则。其他标点符号则没有特殊含义。

如果不记得哪些标点符号需要反斜线转义，可以在每个标点符号前都加上反斜线。另需要注意，许多字母和数字在有反斜线做前缀时也有特殊含义，所以对于想按照直接量进行匹配的字母和数字，尽量不要用反斜线对其转义。如果需要匹配反斜线，则使用`\\`进行匹配。

### 10.1.2 字符类
将直接量字符单独放进方括号内就组成了字符串(character class)。一个字符类可以匹配它所包含的任意字符。因此，正则表达式`/[abc]/`就和字母`a`、`b`、`c`中的任意一个都匹配。另外可以通过`^`符号来定义否定字符类，它匹配所有不包含在方括号内的字符。定义否定字符类时，需要将`^`符号作为左方括号内的第一个字符。正则表达式`/[^abc]/`匹配的是`a`、`b`、`c`之外的所有字符。字符类可以使用连字符来表示字符范围。要匹配拉丁字母表中的小写字母，可以使用`/[a-z]`，要匹配拉丁字母表中任何字母和数字，则使用`/[a-zA-Z0-9]/`。

由于某些字符类非常常用，在Javascript的正则表达式语法中，使用了这些特殊字符的转义字符来表示它们。如，`\s`匹配的是空格符、制表符和其他Unicode空白符，`\S`匹配的是非Unicode空白符的字符。

字符 | 匹配
--- | ---
[...] | 方括号内的任意字符
[^...] | 不在方括号内的任意字符
. | 除换行符和其他Unicode行终止符之外的任意字符
\w | 任何ASCII字符组成的单词，等价于[a-zA-Z0-9]
\W | 任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]
\s | 任何Unicode空白符
\S | 任何非Unicode空白符，注意\w与\S不同
\d | 任何ASCII数字，等价于[0-9]
\D | 任何不是ASCII数字，等价于[^0-9]
[\b] | 退格直接量

### 10.1.3 重复
用刚刚学过的正则表达式语法，可以把两位数描述成`/\d\d\/`，四位数描述成`/\d\d\d\d/`。目前还没有方法可以用来描述任意多位的数字，或者描述由三个字母和一个数字构成的字符串。这些正则表达式语法中较为复杂的模式都提到了正则表达式中某元素的重复出现次数。

在正则模式之后跟随用以指定字符重复的标记。由于某些重复各类非常常用，因此就有一些专门用于表示这种情况的特殊字符。如，`+`匹配一个模式的一个或多个副本。

字符 | 含义
--- | ---
{n,m} | 匹配前一项至少n次，但不能超过m次
{n,} | 匹配前一项n次或者更多次
{n} | 匹配前一项n次
? | 匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}
+ | 匹配前一项1次或多次，等价于{1,}
* | 匹配前一项0次或多次，等价于{0,}

如：

```javascript
/\d{2,4}/		// 匹配2~4个数字
/\w{3}\d?/		// 精确匹配三个字母和一个可选的数字
/\s+java\s+/	// 匹配前后带有一个或多个空白字符的字符串"java"
/[^(]*/			// 匹配0个或多个非左括号字符
```

在使用`*`和`?`时要注意，由于这些字符可能匹配0个字符，因此它们允许什么都不匹配。如，正则表达式`/a*/`实际上与字符串`"bbbb"`匹配，因为这个字符串含有0个a。

### 非贪婪的重复
上表列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，称之为贪婪的匹配。同样可以使用正则表达式进行非贪婪匹配。只须在待匹配的字符串后跟随一个问号即可：`??`、`+?`、`*?`或`{1,5}?`。正则表达式`/a+/`可以匹配一个或多个连续的字母a，当使用"aaa"作为匹配字符串时，正则表达式会匹配它的三个字符。但是`/a+?/`也可以匹配一个或多个连续的字母a，但它是尽可能少地匹配。同样将"aaa"作为匹配字符串，但后一个模式只能匹配第一个a。

使用非贪婪的匹配模式所得到的结果可能和期望并不一致。考虑以下正则表达式`/a+b/`，它可以匹配一个或多个a，以及一个b。当使用"aaab"作为匹配字符串时，它会匹配整个字符串。现在再试一下非贪婪匹配的版本`/a+?b/`，它匹配尽可能少的a和一个b。当用它来匹配"aaab"时，期望它能匹配一个a和最后一个b。但实际这个模式匹配了整个字符串，和该模式的贪婪匹配一样。这是因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。

### 10.1.4 选择、分组和引用
正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。字符"|"用于分隔代选择的字符。如，`/ab|cd|ef/`可以匹配字符串"ab"，也可以匹配字符中"cd"，还可以匹配字符串"ef"。`/\d{3}|[a-z]{4}/`匹配的是三位数字或者四个小字字母。

注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。因此，当正则表达式`/a|ab/`匹配字符串"ab"时，它只能匹配第一个字符。

正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用"|"、"*"、"+"或者"?"等来对单元内的项进行处理。例如，`/java(script)?/`可以匹配字符串"java"，其后可以有"script"也可以没有。`/(ab|cd)+|ef/`可以匹配字符串"ef"，也可以匹配字符串"ab"或"cd"的一次和多次重复。

在正则表达式中，圆括号的另一个作用是在完整的模式中字义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。如，假定正在检索的模式是一个或多个不写字母后面跟随了一位或多位数字，则可以使用模式`/[a-z]+\d+/`。但假定真正关心的是每个匹配的尾部数字，那么如果将模式的数字部分放在括号中`/[a-z]+(\d+)/`，就可以从检索到的匹配中抽取数字了。

圆括号的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。这是通过在字符"\"后加一位或多位数字实现的。这个数字指定了带圆括号的子表达式在正则表达中的位置。如，`\1`引用的是第一个带圆括号的子表达式，`\3`引用的是第三个带圆括号的子表达式。因为子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。如，在下面的正则表达式中，嵌套的了表达式`([Ss]cript)`可以用`\2`来指代：

```javascript
/([Jj]ava([Ss]cript)?\sis\s(fun\w*)/
```

对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。如，下面的正则表达式匹配的就是位于单引号或双引号之内的0个或多个字符。但是，它并不要求左侧和右侧的引号匹配(即，加入的两个引号都是单引号或都是双引号):

```javascript
/['"][^'"]*['"]/
```

如果要匹配左侧和右侧的引号，可以使用如下的引用：

```javascript
/(['"])[^'"]*\1/
```

`/1`匹配的是第一个带圆括号的子表达式所匹配的模式。在上面的例子中，存在这样的一条给，那已经左侧的引号必须和右侧的引号相匹配。正则表达式不允许用双引号括起来的内容中有单引号，反之亦然，不能在字符类中使用这种引用，下面的写法是非法的：

```javascript
/(['"])[^\1]*\1/
```

同样，在正则表达式中不用创建带数字编码的引用，也可以对子表达式进行分组。它不是以"("和")"进行分组的，而是以"(?:"和")"来进行分组的，如考虑下面这个模式：

```javascript
/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/
```

这里，子表达式`(?:[Ss]cript)`仅仅用于分组，因此复制符号"?"可以应用到各个分组。这种改进的圆括号并不生成引用，所以在这个表达式中，`\2`引用了与`(fun\w*)`匹配的文本。

字符 | 含义
--- | ---
\| | 选择，匹配的是该符号左边的子表达式或右边的子表达式
(...) | 组合，将几个项组合为一个单元，这个单元可通过"*"、"+"、"?"、"|"等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用


### 10.1.5 指定匹配位置

### 10.1.6 修饰符

## 10.2 用于模式匹配的String方法

## 10.3 RegExp对象

### 10.3.1 RegExp的属性



Author website: [furzoom](http://furzoom.com/about-us/ "Furzoom")
